## Quick orientation — what this repo is

- Stack: React + TypeScript with Vite. Styling uses Tailwind + Mantine. Routing is file-based via TanStack Router + generated route tree (`src/routeTree.gen.ts`).
- Code organization you will frequently touch:
  - `src/routes/` — file-based route components; each route typically exports `export const Route = createFileRoute(...)`.
  - `src/routes/__root.tsx` — global layout + MantineProvider, site theme tokens, and <NotFound /> wiring.
  - `src/services/` — thin back-end integration layer (Firebase config in `firebase.ts`, API builder in `api.ts`, typed contracts in `types.ts`, hooks in `hooks.ts`).
  - `src/components/` — shared UI bits (e.g., `components/not-found.tsx`).

## How this project runs (developer commands)

- Install dependencies: `pnpm install`
- Dev server: `pnpm dev` (Vite defaults port 3000)
- Build: `pnpm build`
- Preview production build: `pnpm serve`
- Tests: `pnpm test` (Vitest)

Environment variables you must set for local dev:

- VITE_FIREBASE_API_KEY
- VITE_FIREBASE_APP_ID
- VITE_FIREBASE_AUTH_DOMAIN
- VITE_FIREBASE_MESSAGING_SENDER_ID
- VITE_FIREBASE_PROJECT_ID
- VITE_FIREBASE_STORAGE_BUCKET
- VITE_FIREBASE_CLIENT_ID

Do NOT commit these values to source control — the app imports them in `src/services/firebase.ts`.

## Routing & server model — short facts for an agent

- Routes are file-based under `src/routes`. Avoid editing `src/routeTree.gen.ts`: it is generated by TanStack Router. Create or change a file under `src/routes` and the route generator will pick it up.
- Each route file usually exports a `Route` constant created by `createFileRoute(...)`. Use that pattern when adding views.
- Routes may use `loader`/`preload` patterns and React Server/SSR features (this project uses `@tanstack/react-start`). Check `src/routes/*` for examples.
- Every route component is a React function component. Use function declarations, not arrow functions.

## Styles & UI patterns

- UI is a mix of Tailwind classes and Mantine components. Prefer Mantine components for interactive UI (forms, modals, notifications), and Tailwind for layout/utility styling.
- Theme tokens are defined in `src/routes/__root.tsx` via Mantine color tuples (e.g. `deep-forest`, `institutional-green`, `vibrant-lime`). Reuse these tokens where possible.
- Avoid raw string CSS for inline `style="..."` in TSX — use `style={{ ... }}` objects. Many files were converted to this pattern.
- Components meant specifically for a certain route should live in a subfolder under the layouts folder. Shared components go in `src/components/`.

## Data & integrations

- Firebase is the primary backend: auth + Firestore. Config in `src/services/firebase.ts`. The Firestore typed model is in `src/services/types.ts`.
- The repository also uses an internal `@ibnlanre/builder` API abstraction in `src/services/api.ts`. Inspect `api.$use` patterns when writing hooks or server functions.
- Payments are hinted at in types (Paystack/Stripe comment) but not integrated here — search `mandate` pages to see how payment flows are scaffolded.

## Common mistakes to avoid (for AI agents)

- Don't modify `src/routeTree.gen.ts` — changes are transient and auto-generated.
- TypeScript/TSX expects JS style objects — convert `style="..."` to `style={{ ... }}`. There are active linter checks for this.
- When changing routes, keep the `createFileRoute()` export pattern and the default `component` usage to keep generation and types correct.
- Keep environment secrets out of the repo. If you need runtime config changes, use env vars or a secure secret management flow.

## Useful file examples (copy/expand if you need code patterns)

- Route sample using createFileRoute: `src/routes/_public/index.tsx`
- Firebase config: `src/services/firebase.ts` (env driven)
- Types & domain models: `src/services/types.ts` (source of truth for domain shapes)

## Type Safety & Structure

- Avoid using `any` and `unknown`.
- Use proper, existing types from the `types` folder.
- Remove unused interfaces, types, and legacy definitions.
- Simplify data structures; avoid unnecessary mappings or deeply nested shapes.
- Use interfaces (not type aliases) for React component prop types.

## Dates & Time Handling

- Timestamps must be treated as numbers.
- Use date-fns for all date manipulation (formatting, comparisons, differences, etc.).
- Use dayjs only for date creation / lightweight date usage.
- Never manually parse or manipulate timestamps.

## Imports & File Conventions

- Clean up imports: only import what is actually used.
- Avoid re-exports from root/index barrels — import directly from source files. (It’s fine if the source file itself is an index.)
- All filenames must use kebab-case.
- No default exports; only use named exports.

## Code Style

- Use function declarations, not arrow-function components or anonymous exports.
- Fix variable naming; no underscore-prefixed variables unless required by a library.
- Remove all mock/fake data and fake IDs.
- Only use actual API data throughout the app.

## Forms & Validation

- Use `mantine-form` for all field inputs and form state management.
- Use `{ zod4resolver }` from `"mantine-form-zod-resolver"` for validation.
- Remove custom or ad-hoc validation logic.

## UI/UX & Components

- Replace simple Framer Motion animations with AOS (Animate On Scroll) for scroll-triggered effects.
- AOS is already initialized in the main app — just add `data-aos` attributes.
- Use the shared DataTable component for all tabular data.
- Use lucide-react for SVG icons (unless the icon doesn't exist or is custom-built).

## API Integration

- Ensure all components, pages, forms, and modals use real API endpoints.
- Properly handle loading, error, and success states.
- Use the modals API from `@mantine/modals` to open and manage modals.
- Remove all temporary/fake calculations or static placeholder logic.

## General Requirements

- The final output must be fully functional and wired to production-ready API data.
- Code should be maintainable, predictable, and consistent with the existing project architecture.

---

If anything in this file is unclear, point me at the file or workflow you'd like clarified and I’ll update these instructions.  
Short and practical — aim for small, verifiable edits rather than broad refactors unless tests + dev preview are included.
